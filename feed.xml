<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en, cn"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://tyy-x.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://tyy-x.github.io/" rel="alternate" type="text/html" hreflang="en, cn"/><updated>2024-11-03T14:20:35+00:00</updated><id>https://tyy-x.github.io/feed.xml</id><title type="html">Pensieve</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Build the Linux kernel</title><link href="https://tyy-x.github.io/blog/2024/Build-and-Running-Modules/" rel="alternate" type="text/html" title="Build the Linux kernel"/><published>2024-10-27T00:00:00+00:00</published><updated>2024-10-27T00:00:00+00:00</updated><id>https://tyy-x.github.io/blog/2024/Build-and-Running-Modules</id><content type="html" xml:base="https://tyy-x.github.io/blog/2024/Build-and-Running-Modules/"><![CDATA[<p>Recently, I started reading the book Linux Device Drivers with the goal of writing my own driver someday. Although the book is based on a rather old kernel version (v2.6.10), I decided to follow its instructions to build and run an example driver module on the latest kernel release, v6.11.5. To my surprise, the instructions still worked perfectly!</p> <p>Before I could perform the experiments in the book, I needed to build the kernel myself, as the book mentions that building modules for v2.6.x requires a complete built kernel tree on my system. However, the book does not provide any instructions for building a kernel, so I documented the entire process here.</p> <h2 id="build-and-install-the-kernel">Build and install the kernel</h2> <p>There are 5 steps:</p> <ul> <li>install the source</li> <li>install dependcies</li> <li>configure the kernel</li> <li>build the kernel</li> <li>install the kernel</li> </ul> <h3 id="install-the-source">Install the source</h3> <ul> <li>Download the latest release from <a href="https://www.kernel.org/">The Linux Kernel Archives</a> as a compressed tar ball <code class="language-plaintext highlighter-rouge">linux-6.11.5.tar.xz</code></li> <li>Uncompress it using tar <code class="language-plaintext highlighter-rouge">tar xf &lt;path-to-downloaded-source&gt;</code></li> <li><code class="language-plaintext highlighter-rouge">cd</code> into the kernel source directory and do <code class="language-plaintext highlighter-rouge">make mrproper</code> to make sure the directory is clean</li> </ul> <p>Now, the source is properly installed on my system.</p> <h3 id="install-the-dependcies">Install the dependcies</h3> <p>Here is the list of dependcies I installed on a freshly installed Debian 12.7.0:</p> <ul> <li>make</li> <li>gcc</li> <li>flex</li> <li>bison</li> <li>libncurses-dev (needed to run <code class="language-plaintext highlighter-rouge">make menuconfig</code>)</li> <li>pkg-config</li> <li>libssl-dev (build error if not installed)</li> <li>libelf-dev (build error if not installed)</li> </ul> <p>Note that there are other dependcies not listed, as they come bundled with the Debian distribution. For a complete list, refer to the kernel documentation at <code class="language-plaintext highlighter-rouge">Documentation/process/changes.rst</code>.</p> <h3 id="configure-the-kernel">Configure the kernel</h3> <p>Before building the kernel, you need to configure it first. Since there are thousands of configuration parameters, configuring them all from scratch is impratical. A more efficient approach is to copy the configuration from the currently running kernel and use that as a starting point.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/kernel-build/v6.11.5
<span class="nb">cp</span> <span class="nt">-v</span> /boot/config-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/kernel-build/v6.11.5/.config
</code></pre></div></div> <h3 id="build-the-kernel">Build the kernel</h3> <p>This step is straightforward but time consuming (it took me nearly 2 hours!). Run the following command:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j2</span> <span class="nv">O</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/kernel-build/v6.11.5
</code></pre></div></div> <p>To reduce the build time, I may need to further configure the kernel to exclude unnecessary components.</p> <h3 id="install-the-kernel">Install the kernel</h3> <p>To install the new kernel, run another <code class="language-plaintext highlighter-rouge">make</code> command with <code class="language-plaintext highlighter-rouge">sudo</code>:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>make <span class="nv">O</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/kernel-build/v6.11.5 modules_install <span class="nb">install</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">modules_install</code> target is necessary if any kernel components are configured as modules.</p> <p>If everything goes well, reboot the system, and the bootloader (<strong><em>GRUB</em></strong>) should select the new kernel by default. Unfortunately, I encountered an issue: the <code class="language-plaintext highlighter-rouge">initramfs</code> image was too large and the reboot failed. While the Debian kernel’s initramfs is about 30 MB, the initramfs for my new kernel exceeded 400 MB! The <code class="language-plaintext highlighter-rouge">initramfs</code> of the Debian kernel is 30M, but the one of my new kernel is above 400M! To resolve this, I edited the configuration file for <code class="language-plaintext highlighter-rouge">update-initramfs</code>, changing the <code class="language-plaintext highlighter-rouge">MODULES</code> option from <code class="language-plaintext highlighter-rouge">most</code> to <code class="language-plaintext highlighter-rouge">dep</code>, and then regenerated the initramfs with <code class="language-plaintext highlighter-rouge">sudo update-initramfs -u</code>.</p> <h4 id="summary-of-the-kernel-installation-process">Summary of the Kernel Installation Process:</h4> <ul> <li><code class="language-plaintext highlighter-rouge">make install</code> triggers the <code class="language-plaintext highlighter-rouge">/scripts/install.sh</code> script</li> <li>On my system, <code class="language-plaintext highlighter-rouge">install.sh</code> calls <code class="language-plaintext highlighter-rouge">installkernel</code>, a Debian-provided kernel installation script</li> <li><code class="language-plaintext highlighter-rouge">installkenel</code> executes all scripts in <code class="language-plaintext highlighter-rouge">/etc/kernel/postinst.d/</code> using <code class="language-plaintext highlighter-rouge">run-parts</code>, which runs: <ul> <li><code class="language-plaintext highlighter-rouge">run-parts --verbose --exit-on-error --arg="$ver" --arg="$dir/$img_dest-$ver" /etc/kernel/postinst.d</code></li> <li>the first script, <code class="language-plaintext highlighter-rouge">initramfs-tools</code>, has a command line at its last line: <code class="language-plaintext highlighter-rouge">update-initramfs -c -k ${version}" "${bootopt}" &gt;&amp;2</code></li> <li>the second script, <code class="language-plaintext highlighter-rouge">zz-update-grub</code>, runs <code class="language-plaintext highlighter-rouge">exec update-grub</code>, which updates the GRUB boot menu to set the new kernel as the default</li> </ul> </li> </ul> <p>The above sequence produces the following installation output:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  INSTALL /boot
run-parts: executing /etc/kernel/postinst.d/initramfs-tools 6.11.5 /boot/vmlinuz-6.11.5
update-initramfs: Generating /boot/initrd.img-6.11.5
W: Possible missing firmware /lib/firmware/i915/mtl_gsc_1.bin <span class="k">for </span>module i915
W: Possible missing firmware /lib/firmware/i915/dg2_huc_gsc.bin <span class="k">for </span>module i915
W: Possible missing firmware /lib/firmware/i915/mtl_huc_gsc.bin <span class="k">for </span>module i915
W: Possible missing firmware /lib/firmware/i915/mtl_guc_70.bin <span class="k">for </span>module i915
W: Possible missing firmware /lib/firmware/i915/bmg_dmc.bin <span class="k">for </span>module i915
W: Possible missing firmware /lib/firmware/i915/xe2lpd_dmc.bin <span class="k">for </span>module i915
run-parts: executing /etc/kernel/postinst.d/zz-update-grub 6.11.5 /boot/vmlinuz-6.11.5
Generating grub configuration file ...
Found background image: /usr/share/images/desktop-base/desktop-grub.png
Found linux image: /boot/vmlinuz-6.11.5
Found initrd image: /boot/initrd.img-6.11.5
Found linux image: /boot/vmlinuz-6.1.0-26-amd64
Found initrd image: /boot/initrd.img-6.1.0-26-amd64
Found linux image: /boot/vmlinuz-6.1.0-25-amd64
Found initrd image: /boot/initrd.img-6.1.0-25-amd64
Warning: os-prober will not be executed to detect other bootable partitions.
Systems on them will not be added to the GRUB boot configuration.
Check GRUB_DISABLE_OS_PROBER documentation entry.
<span class="k">done</span>
</code></pre></div></div>]]></content><author><name>Madeye</name></author><category term="kernel build"/><summary type="html"><![CDATA[Recently, I started reading the book Linux Device Drivers with the goal of writing my own driver someday. Although the book is based on a rather old kernel version (v2.6.10), I decided to follow its instructions to build and run an example driver module on the latest kernel release, v6.11.5. To my surprise, the instructions still worked perfectly!]]></summary></entry><entry><title type="html">极限</title><link href="https://tyy-x.github.io/blog/2024/limit/" rel="alternate" type="text/html" title="极限"/><published>2024-10-01T00:00:00+00:00</published><updated>2024-10-01T00:00:00+00:00</updated><id>https://tyy-x.github.io/blog/2024/limit</id><content type="html" xml:base="https://tyy-x.github.io/blog/2024/limit/"><![CDATA[<p>以下是有关函数极限的非正式定义：</p> <blockquote> <p>If \(f(x)\) is defined for all \(x\) near \(a\), except possibly at \(a\) itself, and if we can ensure that \(f(x)\) is as close as we want to \(L\) by taking \(x\) close enough to \(a\), but not equal to \(a\), we say that the function \(f\) approaches the limit \(L\) as \(x\) approaches \(a\), and we write</p> \[\lim_{x\to{a}} f(x) = L.\] </blockquote> <p>翻译成中文就是： 如果函数\(f\)在\(a\)附近的所有\(x\)上都有定义（可能在\(a\)点本身无定义），并且我们可以通过让 \(f(x)\)足够接近\(a\)（但不等于\(a\)）来保证\(f(x)\)任意接近\(L\)，那么我们称当\(f(x)\)趋近于 \(a\)时，函数\(f\)的极限为\(L\)，并记作</p> \[\lim_{x\to{a}} f(x) = L.\] <p>之所以说这是一个非正式的定义，是因为诸如”足够接近“，“任意接近”之类的表达不是严谨的数学语言。 例如有多接近算是足够接近？任意接近又是怎样的一种接近？只有在用严格的数学语言对这些情形进行描述后， 我们才能得到函数极限的正式定义。</p>]]></content><author><name>Madeye</name></author><category term="mathematics"/><category term="calculus"/><summary type="html"><![CDATA[以下是有关函数极限的非正式定义： If \(f(x)\) is defined for all \(x\) near \(a\), except possibly at \(a\) itself, and if we can ensure that \(f(x)\) is as close as we want to \(L\) by taking \(x\) close enough to \(a\), but not equal to \(a\), we say that the function \(f\) approaches the limit \(L\) as \(x\) approaches \(a\), and we write \[\lim_{x\to{a}} f(x) = L.\]]]></summary></entry><entry><title type="html">Program Counter in ARM Processor</title><link href="https://tyy-x.github.io/blog/2024/pc-in-arm/" rel="alternate" type="text/html" title="Program Counter in ARM Processor"/><published>2024-04-29T00:00:00+00:00</published><updated>2024-04-29T00:00:00+00:00</updated><id>https://tyy-x.github.io/blog/2024/pc-in-arm</id><content type="html" xml:base="https://tyy-x.github.io/blog/2024/pc-in-arm/"><![CDATA[<p>In x86 architecture, as we all know, the program counter register (actually called the instruction pointer in x86, same thing with a different name) always points to the next instruction to be executed during normal program flow (i.e. without branching). Well, this is not the case for a 32-bit ARM processor. In 32-bit ARM architecture, instead of pointing to the next intruction to be executed, the PC always points to the next instruction to be <strong>fetched</strong>. This means that the PC value of an ARM instruction is its address plus 8 due to a legacy of the three stage pipeline of the original ARM1 processor as illustrated in the picture below. We can see that when the first <code class="language-plaintext highlighter-rouge">MOV</code> instruction is being executed, the third <code class="language-plaintext highlighter-rouge">MOV</code> instruction whose address is the current PC value is being fetched.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/pipeline-480.webp 480w,/assets/img/pipeline-800.webp 800w,/assets/img/pipeline-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/pipeline.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>To see this in real code, we can examine the machine code of the <code class="language-plaintext highlighter-rouge">B</code> instruction which is used for branching. The following is the disassembly of a piece of ARM assembler code containing the <code class="language-plaintext highlighter-rouge">B</code> instruction: <code class="language-plaintext highlighter-rouge">b 0x10058</code> and its machine code <code class="language-plaintext highlighter-rouge">eafffffe</code> in hexadecimal. <code class="language-plaintext highlighter-rouge">0x10058</code> is the address of the target instruction, i.e. the instruction that the processor is about to jump to.</p> <div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">0x00010058 &lt;+4&gt;</span><span class="o">:</span>     <span class="nf">eafffffe        b       0x10058 &lt;_start+4&gt;</span>
<span class="nl">0x0001005C &lt;+8&gt;</span><span class="o">:</span>     <span class="nf">...</span>
<span class="nl">0x00010060 &lt;+10&gt;</span><span class="o">:</span>    <span class="nf">...</span>
</code></pre></div></div> <p>In this case it simply branches to itself which effectively causes the program to stop there forever. The picture below shows the encoding of the <code class="language-plaintext highlighter-rouge">B</code> instruction.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/encoding-480.webp 480w,/assets/img/encoding-800.webp 800w,/assets/img/encoding-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/encoding.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Now when the processor executes a branch instruction, it uses the current PC value to create the address of the target instruction using the following formula:</p> \[address\ of\ the\ target\ instruction = PC + imm24 &lt;&lt; 2.\] <p>For our case here, the <code class="language-plaintext highlighter-rouge">imm24</code> field equals to <code class="language-plaintext highlighter-rouge">fffffe</code> which is the 2’s complement of <code class="language-plaintext highlighter-rouge">-2</code>. Shifting this number to the left by 2 bits effectively multipies it by 4 which gives us <code class="language-plaintext highlighter-rouge">-8</code>. Then <code class="language-plaintext highlighter-rouge">-8</code> is added to the current PC value <code class="language-plaintext highlighter-rouge">0x00010060</code> to give our target instruction’s address. By the way, the <code class="language-plaintext highlighter-rouge">imm24 &lt;&lt; 2</code> part is the offset from the current PC value to the target instruction. This method of calculating instruction’s address is called <strong><em>PC-relative addressing</em></strong>.</p>]]></content><author><name>Madeye</name></author><category term="ARM"/><summary type="html"><![CDATA[In x86 architecture, as we all know, the program counter register (actually called the instruction pointer in x86, same thing with a different name) always points to the next instruction to be executed during normal program flow (i.e. without branching). Well, this is not the case for a 32-bit ARM processor. In 32-bit ARM architecture, instead of pointing to the next intruction to be executed, the PC always points to the next instruction to be fetched. This means that the PC value of an ARM instruction is its address plus 8 due to a legacy of the three stage pipeline of the original ARM1 processor as illustrated in the picture below. We can see that when the first MOV instruction is being executed, the third MOV instruction whose address is the current PC value is being fetched.]]></summary></entry><entry><title type="html">Xv6</title><link href="https://tyy-x.github.io/blog/2024/xv6/" rel="alternate" type="text/html" title="Xv6"/><published>2024-04-26T00:00:00+00:00</published><updated>2024-04-26T00:00:00+00:00</updated><id>https://tyy-x.github.io/blog/2024/xv6</id><content type="html" xml:base="https://tyy-x.github.io/blog/2024/xv6/"><![CDATA[<p>This post marks the starting point of my journey into the world of operating systems by examining a particular one called <a href="https://github.com/mit-pdos/xv6-public">xv6</a>.</p> <p>Xv6 is a teaching operating system developed by the people in MIT. There are two official versions of xv6. It is first developed targeting the x86 architecture, later their effort moves to the development for the new RISC-V architecture. And the original x86 version is no longer under development.</p> <p>I chose the x86 version simply because I want to know more about the x86 architecture.</p> <h2 id="environment-to-build-and-run-the-kernel">Environment to build and run the kernel</h2> <p>I have a Debian 12 system set up on my old Macbook Pro which uses an Intel CPU (Core i5-6287U, dual cores, 4 threads). To build and/or debug the kernel, a compiler toolchain and various other tools (such as <strong>Make, GDB</strong>) are needed. To run the kernel, I need <a href="https://www.qemu.org/docs/master/about/index.html">QEMU</a>. QEMU is a machine emulator which can be used for system emulation and user mode emulation. System emulation provides a virtual model of an entire machine (CPU, memory and emulated devices) to run a guest OS. Obviously, this is what I need. To install QEMU on Debian, just run this command:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>qemu-system-x86
</code></pre></div></div> <p>Now I describe the steps to build and run the kernel.</p> <h3 id="get-the-source-code">Get the source code</h3> <p>I cloned the original repo of xv6 as xv6-x86 to my local machine:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/clone-480.webp 480w,/assets/img/clone-800.webp 800w,/assets/img/clone-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/clone.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="build">Build</h2> <p>Now, it’s time to build the kernel. Run <code class="language-plaintext highlighter-rouge">make</code> inside the root directory of the cloned repository:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/build-480.webp 480w,/assets/img/build-800.webp 800w,/assets/img/build-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/build.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>You can see that there is something wrong in the source file <strong>mp.c</strong> that causes gcc to report errors. Of course the permanent solution is to fix those problems (which look like bugs based on the error descriptions), but now I just want to make sure that the kernel is runable. So the workaround here is to modify the flags passed to gcc. Take a look at the <strong>Makefile</strong>, you can see that the option <code class="language-plaintext highlighter-rouge">-Werror</code> is passed to gcc, so gcc will make all warnings into errors.</p> <div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-fno-pic</span> <span class="nt">-static</span> <span class="nt">-fno-builtin</span> <span class="nt">-fno-strict-aliasing</span> <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-MD</span> <span class="nt">-ggdb</span> <span class="nt">-m32</span> <span class="nt">-Werror</span> <span class="nt">-fno-omit-frame-pointer</span>
</code></pre></div></div> <p>Just delete the <code class="language-plaintext highlighter-rouge">-Werror</code> option then Make will run quietly:</p> <div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
</span><span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-fno-pic</span> <span class="nt">-static</span> <span class="nt">-fno-builtin</span> <span class="nt">-fno-strict-aliasing</span> <span class="nt">-O2</span> <span class="nt">-Wall</span> <span class="nt">-MD</span> <span class="nt">-ggdb</span> <span class="nt">-m32</span> <span class="nt">-fno-omit-frame-pointer</span>
</code></pre></div></div> <h2 id="run-the-kernel">Run the kernel</h2> <p>To run the kernel inside qemu, just run the command <code class="language-plaintext highlighter-rouge">make qemu</code>:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/qemu-480.webp 480w,/assets/img/qemu-800.webp 800w,/assets/img/qemu-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/qemu.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Wonderful! Despite the problems in the source code, xv6 boots and runs inside qemu. Now let’s try some shell commands.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/commands-480.webp 480w,/assets/img/commands-800.webp 800w,/assets/img/commands-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/commands.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The <code class="language-plaintext highlighter-rouge">ls</code> and <code class="language-plaintext highlighter-rouge">echo</code> commands run perfectly! How very exciting!</p>]]></content><author><name>Madeye</name></author><category term="xv6"/><category term="OS"/><summary type="html"><![CDATA[This post marks the starting point of my journey into the world of operating systems by examining a particular one called xv6.]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://tyy-x.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog"/><published>2022-04-23T23:20:09+00:00</published><updated>2022-04-23T23:20:09+00:00</updated><id>https://tyy-x.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://tyy-x.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[]]></content><author><name></name></author></entry></feed>